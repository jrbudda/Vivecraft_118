--- a/net/minecraft/client/Minecraft.java
+++ b/net/minecraft/client/Minecraft.java
@@ -18,7 +18,9 @@
 import com.mojang.blaze3d.pipeline.TextureTarget;
 import com.mojang.blaze3d.platform.DisplayData;
 import com.mojang.blaze3d.platform.GlDebug;
+import com.mojang.blaze3d.platform.GlStateManager;
 import com.mojang.blaze3d.platform.GlUtil;
+import com.mojang.blaze3d.platform.MemoryTracker;
 import com.mojang.blaze3d.platform.Window;
 import com.mojang.blaze3d.platform.WindowEventHandler;
 import com.mojang.blaze3d.systems.RenderSystem;
@@ -40,20 +42,33 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.UncheckedIOException;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
 import java.net.Proxy;
 import java.net.SocketAddress;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.nio.Buffer;
 import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.FloatBuffer;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.text.DecimalFormat;
 import java.text.DecimalFormatSymbols;
 import java.text.SimpleDateFormat;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.Date;
+import java.util.Deque;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
 import java.util.MissingResourceException;
 import java.util.Queue;
+import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ExecutionException;
@@ -106,6 +121,7 @@
 import net.minecraft.client.gui.screens.social.SocialInteractionsScreen;
 import net.minecraft.client.gui.screens.worldselection.EditWorldScreen;
 import net.minecraft.client.main.GameConfig;
+import net.minecraft.client.main.Main;
 import net.minecraft.client.model.geom.EntityModelSet;
 import net.minecraft.client.multiplayer.ClientHandshakePacketListenerImpl;
 import net.minecraft.client.multiplayer.ClientLevel;
@@ -153,6 +169,7 @@
 import net.minecraft.client.searchtree.SearchRegistry;
 import net.minecraft.client.server.IntegratedServer;
 import net.minecraft.client.sounds.MusicManager;
+import net.minecraft.client.sounds.SoundEngine;
 import net.minecraft.client.sounds.SoundManager;
 import net.minecraft.client.tutorial.Tutorial;
 import net.minecraft.commands.Commands;
@@ -164,7 +181,9 @@
 import net.minecraft.core.RegistryAccess;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.ListTag;
+import net.minecraft.nbt.NbtOps;
 import net.minecraft.nbt.StringTag;
+import net.minecraft.nbt.Tag;
 import net.minecraft.network.Connection;
 import net.minecraft.network.ConnectionProtocol;
 import net.minecraft.network.chat.ClickEvent;
@@ -229,10 +248,12 @@
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.PlayerHeadItem;
 import net.minecraft.world.item.TooltipFlag;
+import net.minecraft.world.level.DataPackConfig;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.LevelSettings;
 import net.minecraft.world.level.biome.Biome;
 import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.RenderShape;
 import net.minecraft.world.level.block.entity.BlockEntity;
 import net.minecraft.world.level.block.entity.SkullBlockEntity;
@@ -245,14 +266,118 @@
 import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.EntityHitResult;
 import net.minecraft.world.phys.HitResult;
+import net.minecraft.world.phys.Vec3;
+import net.optifine.Config;
+import net.optifine.reflect.Reflector;
+import net.optifine.reflect.ReflectorForge;
+import net.optifine.shaders.Shaders;
+
+import org.apache.commons.io.Charsets;
 import org.apache.commons.io.FileUtils;
+import org.lwjgl.opengl.ARBShaderObjects;
+import org.lwjgl.opengl.GL11;
+import org.lwjgl.opengl.GL30;
 import org.lwjgl.util.tinyfd.TinyFileDialogs;
 import org.slf4j.Logger;
+import org.vivecraft.api.ErrorHelper;
+import org.vivecraft.api.NetworkHelper;
+import org.vivecraft.gameplay.VRPlayer;
+import org.vivecraft.gameplay.screenhandlers.GuiHandler;
+import org.vivecraft.gameplay.screenhandlers.RadialHandler;
+import org.vivecraft.gameplay.trackers.BackpackTracker;
+import org.vivecraft.gameplay.trackers.BowTracker;
+import org.vivecraft.gameplay.trackers.CameraTracker;
+import org.vivecraft.gameplay.trackers.ClimbTracker;
+import org.vivecraft.gameplay.trackers.CrawlTracker;
+import org.vivecraft.gameplay.trackers.EatingTracker;
+import org.vivecraft.gameplay.trackers.HorseTracker;
+import org.vivecraft.gameplay.trackers.InteractTracker;
+import org.vivecraft.gameplay.trackers.JumpTracker;
+import org.vivecraft.gameplay.trackers.RowTracker;
+import org.vivecraft.gameplay.trackers.RunTracker;
+import org.vivecraft.gameplay.trackers.SneakTracker;
+import org.vivecraft.gameplay.trackers.SwimTracker;
+import org.vivecraft.gameplay.trackers.SwingTracker;
+import org.vivecraft.gameplay.trackers.TeleportTracker;
+import org.vivecraft.gameplay.trackers.TelescopeTracker;
+import org.vivecraft.gameplay.trackers.VehicleTracker;
+import org.vivecraft.menuworlds.MenuWorldRenderer;
+import org.vivecraft.provider.MCVR;
+import org.vivecraft.provider.VRRenderer;
+import org.vivecraft.provider.openvr_jna.MCOpenVR;
+import org.vivecraft.provider.openvr_jna.OpenVRStereoRenderer;
+import org.vivecraft.provider.openvr_jna.VRInputAction;
+import org.vivecraft.provider.ovr_lwjgl.MC_OVR;
+import org.vivecraft.provider.ovr_lwjgl.OVR_StereoRenderer;
+import org.vivecraft.render.OpenGLdebugging;
+import org.vivecraft.render.PlayerModelController;
+import org.vivecraft.render.RenderConfigException;
+import org.vivecraft.render.RenderPass;
+import org.vivecraft.render.VRFirstPersonArmSwing;
+import org.vivecraft.render.VRShaders;
+import org.vivecraft.settings.VRHotkeys;
+import org.vivecraft.settings.VRSettings;
+import org.vivecraft.utils.LangHelper;
+import org.vivecraft.utils.Utils;
+import org.vivecraft.utils.math.Vector3;
 
-public class Minecraft extends ReentrantBlockableEventLoop<Runnable> implements WindowEventHandler
+public class Minecraft extends ReentrantBlockableEventLoop<Runnable> implements WindowEventHandler, net.minecraftforge.client.extensions.IForgeMinecraft
 {
     private static Minecraft instance;
     private static final Logger LOGGER = LogUtils.getLogger();
+    public VRPlayer vrPlayer;
+    public MCVR vr;
+    public VRRenderer vrRenderer;
+    public BackpackTracker backpackTracker = new BackpackTracker(this);
+    public BowTracker bowTracker = new BowTracker(this);
+    public SwimTracker swimTracker = new SwimTracker(this);
+    public EatingTracker autoFood = new EatingTracker(this);
+    public JumpTracker jumpTracker = new JumpTracker(this);
+    public SneakTracker sneakTracker = new SneakTracker(this);
+    public ClimbTracker climbTracker = new ClimbTracker(this);
+    public RunTracker runTracker = new RunTracker(this);
+    public RowTracker rowTracker = new RowTracker(this);
+    public TeleportTracker teleportTracker = new TeleportTracker(this);
+    public SwingTracker swingTracker = new SwingTracker(this);
+    public HorseTracker horseTracker = new HorseTracker(this);
+    public VehicleTracker vehicleTracker = new VehicleTracker(this);
+    //public PhysicalGuiManager physicalGuiManager = new PhysicalGuiManager(this);
+    public InteractTracker interactTracker = new InteractTracker(this);
+    public CrawlTracker crawlTracker = new CrawlTracker(this);
+    public CameraTracker cameraTracker = new CameraTracker(this);
+    public ThreadGroup backgroundThreadGroup = new ThreadGroup("background");
+    public final float PIOVER180 = ((float)Math.PI / 180F);
+    public int lastShaderIndex = -1;
+    public Field fieldHwnd = null;
+    public Field fieldDisplay = null;
+    public Field fieldWindow = null;
+    public Field fieldResized = null;
+    public Method fieldResizedMethod = null;
+    public VRSettings vrSettings;
+    public long lastIntegratedServerLaunchCheck = 0L;
+    public boolean integratedServerLaunchInProgress = false;
+    public boolean grabScreenShot = false;
+    public boolean lastShowMouseNative = true;
+    public boolean enableWorldExport = false;
+    public SoundEngine sndManager = null;
+    public MenuWorldRenderer menuWorldRenderer;
+    private FloatBuffer matrixBuffer = MemoryTracker.create(16).asFloatBuffer();
+    private FloatBuffer matrixBuffer2 = MemoryTracker.create(16).asFloatBuffer();
+    private boolean firstInit = true;
+    public boolean showSplashScreen = true;
+    public long splashTimer1 = 0L;
+    public long splashTimer2 = 0L;
+    private RenderTarget splash;
+    private float splashFadeAlpha = 0.0F;
+    public Deque<Long> runTickTimeNanos = new ArrayDeque<>();
+    public long medianRunTickTimeNanos = 0L;
+    public long frameIndex = 0L;
+    public ErrorHelper errorHelper;
+    public RenderPass currentPass;
+    private boolean lastClick;
+    public boolean resourcePacksChanged;
+    public int tickCounter;
+    public final String minecriftVerString = "Vivecraft 1.18.2  jrbudda-VR-3-b7";
     public static final boolean ON_OSX = Util.getPlatform() == Util.OS.OSX;
     private static final int MAX_TICKS_PER_UPDATE = 10;
     public static final ResourceLocation DEFAULT_FONT = new ResourceLocation("default");
@@ -282,7 +407,7 @@
     public final DebugRenderer debugRenderer;
     private final AtomicReference<StoringChunkProgressListener> progressListener = new AtomicReference<>();
     public final Gui gui;
-    public final Options options;
+    public Options options;
     private final HotbarManager hotbarManager;
     public final MouseHandler mouseHandler;
     public final KeyboardHandler keyboardHandler;
@@ -302,7 +427,7 @@
     private final LanguageManager languageManager;
     private final BlockColors blockColors;
     private final ItemColors itemColors;
-    private final RenderTarget mainRenderTarget;
+    public RenderTarget mainRenderTarget;
     private final SoundManager soundManager;
     private final MusicManager musicManager;
     private final FontManager fontManager;
@@ -382,6 +507,14 @@
     private MetricsRecorder metricsRecorder = InactiveMetricsRecorder.INSTANCE;
     private final ResourceLoadStateTracker reloadStateTracker = new ResourceLoadStateTracker();
     private String debugPath = "root";
+    private float fov = 1.0F;
+    public float watereffect;
+    public float portaleffect;
+    public float pumpkineffect;
+    long mirroNotifyStart;
+    String mirrorNotifyText;
+    boolean mirrorNotifyClear;
+    long mirroNotifyLen;
 
     public Minecraft(GameConfig pGameConfig)
     {
@@ -400,8 +533,6 @@
         this.minecraftSessionService = yggdrasilauthenticationservice.createMinecraftSessionService();
         this.userApiService = this.createUserApiService(yggdrasilauthenticationservice, pGameConfig);
         this.user = pGameConfig.user.user;
-        LOGGER.info("Setting user: {}", (Object)this.user.getName());
-        LOGGER.debug("(Session ID is {})", (Object)this.user.getSessionId());
         this.demo = pGameConfig.game.demo;
         this.allowsMultiplayer = !pGameConfig.game.disableMultiplayer;
         this.allowsChat = !pGameConfig.game.disableChat;
@@ -424,6 +555,23 @@
         KeybindComponent.setKeyResolver(KeyMapping::createNameSupplier);
         this.fixerUpper = DataFixers.getDataFixer();
         this.toast = new ToastComponent(this);
+        if (!Main.oculus)
+        {
+            this.vr = new MCOpenVR(this);
+        }
+        else
+        {
+            this.vr = new MC_OVR(this);
+        }
+
+        VRSettings.initSettings(this, this.gameDirectory);
+
+        if (!this.vrSettings.badStereoProviderPluginID.isEmpty())
+        {
+            this.vrSettings.stereoProviderPluginID = this.vrSettings.badStereoProviderPluginID;
+            this.vrSettings.badStereoProviderPluginID = "";
+            this.vrSettings.saveOptions();
+        }
         this.gameThread = Thread.currentThread();
         this.options = new Options(this, this.gameDirectory);
         this.tutorial = new Tutorial(this, this.options);
@@ -441,6 +589,9 @@
         }
 
         Util.timeSource = RenderSystem.initBackendSystem();
+        if(ReflectorForge.getConfigClientBoolean(Reflector.ForgeConfig_Client_forceSystemNanoTime, false))
+        	Util.timeSource = System::nanoTime;
+
         this.virtualScreen = new VirtualScreen(this);
         this.window = this.virtualScreen.newWindow(displaydata, this.options.fullscreenVideoModeString, this.createTitle());
         this.setWindowActive(true);
@@ -461,14 +612,19 @@
 
         this.window.setFramerateLimit(this.options.framerateLimit);
         this.mouseHandler = new MouseHandler(this);
-        this.mouseHandler.setup(this.window.getWindow());
+        //Forge
+        //this.mouseHandler.setup(this.window.getWindow());
+        //
         this.keyboardHandler = new KeyboardHandler(this);
         this.keyboardHandler.setup(this.window.getWindow());
         RenderSystem.initRenderer(this.options.glDebugVerbosity, false);
-        this.mainRenderTarget = new MainTarget(this.window.getWidth(), this.window.getHeight());
+        this.mainRenderTarget = new MainTarget(this.window.getScreenWidth(), this.window.getScreenHeight());
         this.mainRenderTarget.setClearColor(0.0F, 0.0F, 0.0F, 0.0F);
         this.mainRenderTarget.clear(ON_OSX);
         this.resourceManager = new ReloadableResourceManager(PackType.CLIENT_RESOURCES);
+        //Forge
+        Reflector.call(Reflector.ClientModLoader_begin, this, this.resourcePackRepository, this.resourceManager, this.clientPackSource);
+        //
         this.resourcePackRepository.reload();
         this.options.loadSelectedResourcePacks(this.resourcePackRepository);
         this.languageManager = new LanguageManager(this.options.languageCode);
@@ -486,6 +642,16 @@
         this.font = this.fontManager.createFont();
         this.resourceManager.registerReloadListener(this.fontManager.getReloadListener());
         this.selectMainFont(this.isEnforceUnicode());
+        /** MINECRIFT */
+        try
+        {
+            this.initMinecrift();
+        }
+        catch (Exception exception)
+        {
+            exception.printStackTrace();
+        }
+        /** END MINECRIFT */
         this.resourceManager.registerReloadListener(new GrassColorReloadListener());
         this.resourceManager.registerReloadListener(new FoliageColorReloadListener());
         this.window.setErrorSection("Startup");
@@ -517,6 +683,9 @@
         this.createSearchTrees();
         this.resourceManager.registerReloadListener(this.searchRegistry);
         this.particleEngine = new ParticleEngine(this.level, this.textureManager);
+        //Forge
+        Reflector.call(Reflector.call(Reflector.fml_ModLoader_get), Reflector.fml_ModLoader_postEvent, Reflector.newInstance(Reflector.ParticleFactoryRegisterEvent_Constructor));
+        //
         this.resourceManager.registerReloadListener(this.particleEngine);
         this.paintingTextures = new PaintingTextureManager(this.textureManager);
         this.resourceManager.registerReloadListener(this.paintingTextures);
@@ -525,7 +694,15 @@
         this.gpuWarnlistManager = new GpuWarnlistManager();
         this.resourceManager.registerReloadListener(this.gpuWarnlistManager);
         this.resourceManager.registerReloadListener(this.regionalCompliancies);
-        this.gui = new Gui(this);
+        if (Reflector.ForgeIngameGui_Constructor.exists())
+        {
+            this.gui = (Gui)Reflector.newInstance(Reflector.ForgeIngameGui_Constructor, this);
+        }
+        else
+        {
+        	this.gui = new Gui(this);
+        }
+        this.mouseHandler.setup(this.window.getWindow()); //Forge: Moved below ingameGUI setting to prevent NPEs in handeler.
         this.debugRenderer = new DebugRenderer(this);
         RenderSystem.setErrorCallback(this::onFullscreenError);
 
@@ -550,16 +727,32 @@
             TinyFileDialogs.tinyfd_messageBox("Minecraft", stringbuilder.toString(), "ok", "error", false);
         }
 
+        //Forge
+        Reflector.call(Reflector.call(Reflector.fml_ModLoader_get), Reflector.fml_ModLoader_postEvent, Reflector.newInstance(Reflector.RegisterClientReloadListenersEvent_Constructor,this.resourceManager));
+        Reflector.call(Reflector.call(Reflector.fml_ModLoader_get), Reflector.fml_ModLoader_postEvent, Reflector.newInstance(Reflector.EntityRenderersEvent_RegisterLayerDefinitions_Constructor));
+        Reflector.call(Reflector.call(Reflector.fml_ModLoader_get), Reflector.fml_ModLoader_postEvent, Reflector.newInstance(Reflector.EntityRenderersEvent_RegisterRenderers_Constructor));
+        //
+        
         this.window.updateVsync(this.options.enableVsync);
         this.window.updateRawMouseInput(this.options.rawMouseInput);
         this.window.setDefaultErrorCallback();
         this.resizeDisplay();
+        //Vivecraft
+        this.menuWorldRenderer = new MenuWorldRenderer();
+        this.vrSettings.firstRun = false;
+        this.vrSettings.saveOptions();
+        //
         this.gameRenderer.preloadUiShader(this.getClientPackSource().getVanillaPack());
         LoadingOverlay.registerTextures(this);
         List<PackResources> list = this.resourcePackRepository.openAllSelected();
         this.reloadStateTracker.startReload(ResourceLoadStateTracker.ReloadReason.INITIAL, list);
         this.setOverlay(new LoadingOverlay(this, this.resourceManager.createReload(Util.backgroundExecutor(), this, RESOURCE_RELOAD_INITIAL_TASK, list), (p_210745_) ->
         {
+            if (this.vrRenderer.isInitialized())
+            {
+                this.menuWorldRenderer.init();
+            }
+            this.vr.postinit();
             Util.ifElse(p_210745_, this::rollbackResourcePacks, () -> {
                 if (SharedConstants.IS_RUNNING_IN_IDE)
                 {
@@ -567,17 +760,21 @@
                 }
 
                 this.reloadStateTracker.finishReload();
+                //Forge
+                if (!Reflector.callBoolean(Reflector.ClientModLoader_completeModLoading))
+                {
+                    if (s != null)
+                    {
+                        ConnectScreen.startConnecting(new TitleScreen(), this, new ServerAddress(s, i), (ServerData)null);
+                    }
+                    else
+                    {
+                        this.setScreen(new TitleScreen(true));
+                    }
+                }
+                //
             });
         }, false));
-
-        if (s != null)
-        {
-            ConnectScreen.startConnecting(new TitleScreen(), this, new ServerAddress(s, i), (ServerData)null);
-        }
-        else
-        {
-            this.setScreen(new TitleScreen(true));
-        }
     }
 
     private static boolean countryEqualsISO3(Object p_210783_)
@@ -599,7 +796,7 @@
 
     private String createTitle()
     {
-        StringBuilder stringbuilder = new StringBuilder("Minecraft");
+        StringBuilder stringbuilder = new StringBuilder(minecriftVerString);
 
         if (checkModStatus().shouldReportAsModified())
         {
@@ -653,17 +850,14 @@
         return ModCheck.identify("vanilla", ClientBrandRetriever::getClientModName, "Client", Minecraft.class);
     }
 
-    private void rollbackResourcePacks(Throwable p_91240_)
-    {
-        if (this.resourcePackRepository.getSelectedIds().size() > 1)
-        {
-            this.clearResourcePacksOnError(p_91240_, (Component)null);
-        }
-        else
-        {
-            Util.throwAsRuntime(p_91240_);
+    private void rollbackResourcePacks(Throwable p_91240_) {
+        if (this.resourcePackRepository.getSelectedPacks().stream().anyMatch(e -> !e.isRequired())) { //Forge: This caused infinite loop if any resource packs are forced. Such as mod resources. So check if we can disable any.
+           this.clearResourcePacksOnError(p_91240_, (Component)null);
+        } else {
+           Util.throwAsRuntime(p_91240_);
         }
-    }
+
+     }
 
     public void clearResourcePacksOnError(Throwable pThrowable, @Nullable Component pErrorMessage)
     {
@@ -797,7 +991,7 @@
         this.searchRegistry.register(SearchRegistry.CREATIVE_TAGS, reloadableidsearchtree);
         this.searchRegistry.register(SearchRegistry.RECIPE_COLLECTIONS, reloadablesearchtree1);
     }
-
+    
     private void onFullscreenError(int p_91114_, long p_91115_)
     {
         this.options.enableVsync = false;
@@ -850,17 +1044,43 @@
         if (pReport.getSaveFile() != null)
         {
             Bootstrap.realStdoutPrintln("#@!@# Game crashed! Crash report saved to: #@!@# " + pReport.getSaveFile());
-            System.exit(-1);
+            //Forge
+            if (Reflector.ServerLifecycleHooks_handleExit.exists())
+            {
+                Reflector.call(Reflector.ServerLifecycleHooks_handleExit, -1);
+            }
+            else
+            {
+                System.exit(-1);
+            }
+            //
         }
         else if (pReport.saveToFile(file2))
         {
             Bootstrap.realStdoutPrintln("#@!@# Game crashed! Crash report saved to: #@!@# " + file2.getAbsolutePath());
-            System.exit(-1);
+            //Forge
+            if (Reflector.ServerLifecycleHooks_handleExit.exists())
+            {
+                Reflector.call(Reflector.ServerLifecycleHooks_handleExit, -1);
+            }
+            else
+            {
+                System.exit(-1);
+            }
+            //
         }
         else
         {
             Bootstrap.realStdoutPrintln("#@?@# Game crashed! Crash report could not be saved. #@?@#");
-            System.exit(-2);
+
+            if (Reflector.ServerLifecycleHooks_handleExit.exists())
+            {
+                Reflector.call(Reflector.ServerLifecycleHooks_handleExit, -2);
+            }
+            else
+            {
+                System.exit(-2);
+            }
         }
     }
 
@@ -901,6 +1121,22 @@
 
                 this.setOverlay(new LoadingOverlay(this, this.resourceManager.createReload(Util.backgroundExecutor(), this, RESOURCE_RELOAD_INITIAL_TASK, list), (p_210750_) ->
                 {
+                	//Vivecraft
+                    if (this.menuWorldRenderer.isReady() && this.resourcePacksChanged)
+                    {
+                        try
+                        {
+                            this.menuWorldRenderer.destroy();
+                            this.menuWorldRenderer.prepare();
+                        }
+                        catch (Exception exception)
+                        {
+                            exception.printStackTrace();
+                        }
+                    }
+                    
+                    this.resourcePacksChanged = false;
+                    //
                     Util.ifElse(p_210750_, this::rollbackResourcePacks, () -> {
                         this.levelRenderer.allChanged();
                         this.reloadStateTracker.finishReload();
@@ -1005,10 +1241,12 @@
             LOGGER.error("setScreen called from non-game thread");
         }
 
-        if (this.screen != null)
-        {
-            this.screen.removed();
-        }
+        //Forge
+        //if (this.screen != null)
+        //{
+        //    this.screen.removed();
+        //}
+        //
 
         if (pGuiScreen == null && this.level == null)
         {
@@ -1026,6 +1264,28 @@
             }
         }
 
+        //Forge
+        Reflector.call(Reflector.ForgeHooksClient_clearGuiLayers, this);
+        Screen screen = this.screen;
+        Object object = Reflector.newInstance(Reflector.ScreenOpenEvent_Constructor, pGuiScreen);
+        if (object != null)
+        {
+            if (Reflector.postForgeBusEvent(object))
+            {
+                return;
+            }
+
+            pGuiScreen = (Screen)Reflector.call(object, Reflector.ScreenOpenEvent_getScreen);
+        }
+        
+        if (screen != null && pGuiScreen != screen)
+        	screen.removed();
+        //
+        
+		// VIVECRAFT
+		GuiHandler.onScreenChanged(this.screen, pGuiScreen, true);
+		// VIVECRAFT        
+        
         this.screen = pGuiScreen;
         BufferUploader.reset();
 
@@ -1088,6 +1348,14 @@
         {
             Util.timeSource = System::nanoTime;
 
+            try
+            {
+                this.vr.destroy();
+            }
+            catch (Exception exception)
+            {
+            }
+
             if (this.delayedCrash == null)
             {
                 System.exit(0);
@@ -1124,11 +1392,11 @@
             this.window.close();
         }
     }
-
+    
+    //Mojang why would you name it this. This is runGameLoop
     private void runTick(boolean pRenderLevel)
     {
         this.window.setErrorSection("Pre render");
-        long i = Util.getNanos();
 
         if (this.window.shouldClose())
         {
@@ -1154,79 +1422,259 @@
 
         if (pRenderLevel)
         {
+            this.options.ofFastRender = false;
+            ++this.frameIndex;
             int j = this.timer.advanceTime(Util.getMillis());
             this.profiler.push("scheduledExecutables");
             this.runAllTasks();
             this.profiler.pop();
+            
+            try {
+                this.vrRenderer.setupRenderConfiguration();
+            }
+            catch (RenderConfigException renderconfigexception)
+            {
+                this.screen = null;
+                GlStateManager._viewport(0, 0, this.window.getScreenWidth(), this.window.getScreenHeight());
+
+                if (this.overlay != null)
+                {
+                    RenderSystem.clear(256, ON_OSX);
+                    Matrix4f matrix4f = Matrix4f.orthographic((float)(this.window.getScreenWidth() / this.window.getGuiScale()), (float)(this.window.getScreenHeight() / this.window.getGuiScale()), 1000.0F, 3000.0F);
+                    RenderSystem.setProjectionMatrix(matrix4f);
+                    PoseStack p = new PoseStack();
+                    p.translate(0, 0, -2000);
+                    this.overlay.render(p, 0, 0, 0.0F);
+                }
+                else
+                {
+                    this.notifyMirror(LangHelper.get("vivecraft.messages.rendersetupfailed", renderconfigexception.error), true, 10000);
+                    this.drawNotifyMirror();
+
+                    if (this.frameIndex % 300L == 0L)
+                    {
+                        System.out.println(renderconfigexception.title + " " + renderconfigexception.error);
+                    }
+
+                    try
+                    {
+                        Thread.sleep(10L);
+                    }
+                    catch (InterruptedException interruptedexception)
+                    {
+                    }
+                }
+
+                this.window.updateDisplay();
+                return;
+            }
+            catch (Exception exception2)
+            {
+                exception2.printStackTrace();
+            }
+
+            this.profiler.push("VR Poll/VSync");
+            this.vr.poll(this.frameIndex);
+            this.profiler.pop();
+            this.vrPlayer.postPoll();
             this.profiler.push("tick");
 
             for (int k = 0; k < Math.min(10, j); ++k)
             {
                 this.profiler.incrementCounter("clientTick");
+                this.vrPlayer.preTick();
                 this.tick();
+                this.vrPlayer.postTick();
             }
 
             this.profiler.pop();
         }
 
+        this.options.ofFastRender = false;
+        this.profiler.push("setupRenderConfiguration");
         this.mouseHandler.turnPlayer();
         this.window.setErrorSection("Render");
         this.profiler.push("sound");
         this.soundManager.updateSource(this.gameRenderer.getMainCamera());
         this.profiler.pop();
-        this.profiler.push("render");
-        PoseStack posestack = RenderSystem.getModelViewStack();
-        posestack.pushPose();
-        RenderSystem.applyModelViewMatrix();
-        RenderSystem.clear(16640, ON_OSX);
-        this.mainRenderTarget.bindWrite(true);
+        try
+        {
+            this.checkGLError("pre render setup ");
+            this.vrRenderer.setupRenderConfiguration();
+            this.checkGLError("post render setup ");
+        }
+        catch (Exception exception1)
+        {
+            exception1.printStackTrace();
+        }
+
+        float f = this.pause ? this.pausePartialTick : this.timer.partialTick;
+        this.profiler.popPush("preRender");
+        this.vrPlayer.preRender(f);      
+        this.profiler.popPush("2D");
+        
+        //PoseStack posestack = RenderSystem.getModelViewStack();
+        //posestack.pushPose();
+        //RenderSystem.applyModelViewMatrix();
+        //RenderSystem.clear(16640, ON_OSX);
+        //this.mainRenderTarget.bindWrite(true);
         FogRenderer.setupNoFog();
-        this.profiler.push("display");
         RenderSystem.enableTexture();
         RenderSystem.enableCull();
-        this.profiler.pop();
+        this.profiler.push("Gui");
+        this.currentPass = RenderPass.GUI;
+        this.gameRenderer.getMainCamera().setup(this.level, this.getCameraEntity(), false, false, f);
 
         if (!this.noRender)
         {
-            this.profiler.popPush("gameRenderer");
-            this.gameRenderer.render(this.pause ? this.pausePartialTick : this.timer.partialTick, i, pRenderLevel);
-            this.profiler.popPush("toasts");
-            this.toast.render(new PoseStack());
-            this.profiler.pop();
+            Reflector.call(Reflector.BasicEventHooks_onRenderTickStart, f);
         }
 
-        if (this.fpsPieResults != null)
+        GlStateManager._depthMask(true);
+        GlStateManager._colorMask(true, true, true, true);
+        this.mainRenderTarget = GuiHandler.guiFramebuffer;
+        this.mainRenderTarget.clear(Minecraft.ON_OSX);
+        this.mainRenderTarget.bindWrite(true);
+        this.gameRenderer.drawFramebufferNEW(f, pRenderLevel, new PoseStack());
+
+        if (org.vivecraft.gameplay.screenhandlers.KeyboardHandler.Showing && !this.vrSettings.physicalKeyboard)
         {
-            this.profiler.push("fpsPie");
-            this.renderFpsMeter(new PoseStack(), this.fpsPieResults);
-            this.profiler.pop();
+            this.mainRenderTarget = org.vivecraft.gameplay.screenhandlers.KeyboardHandler.Framebuffer;
+            this.mainRenderTarget.clear(Minecraft.ON_OSX);
+            this.mainRenderTarget.bindWrite(true);
+            this.gameRenderer.drawScreen(f, org.vivecraft.gameplay.screenhandlers.KeyboardHandler.UI, new PoseStack());
         }
 
-        this.profiler.push("blit");
-        this.mainRenderTarget.unbindWrite();
-        posestack.popPose();
-        posestack.pushPose();
-        RenderSystem.applyModelViewMatrix();
-        this.mainRenderTarget.blitToScreen(this.window.getWidth(), this.window.getHeight());
-        posestack.popPose();
-        RenderSystem.applyModelViewMatrix();
-        this.profiler.popPush("updateDisplay");
-        this.window.updateDisplay();
+        if (RadialHandler.isShowing())
+        {
+            this.mainRenderTarget = RadialHandler.Framebuffer;
+            this.mainRenderTarget.clear(Minecraft.ON_OSX);
+            this.mainRenderTarget.bindWrite(true);
+            this.gameRenderer.drawScreen(f, RadialHandler.UI, new PoseStack());
+        }
+
+        this.checkGLError("post 2d ");
+        this.profiler.pop();
+        VRHotkeys.updateMovingThirdPersonCam();
+        this.profiler.popPush("sound");
+        this.currentPass = RenderPass.CENTER;
+        this.soundManager.updateSource(this.gameRenderer.getMainCamera());
+        this.profiler.pop();
         int i1 = this.getFramerateLimit();
 
-        if ((double)i1 < Option.FRAMERATE_LIMIT.getMaxValue())
+        if (!this.noRender)
         {
-            RenderSystem.limitDisplayFPS(i1);
+            List<RenderPass> list = this.vrRenderer.getRenderPasses();
+
+            for (RenderPass renderpass : list)
+            {
+                this.currentPass = renderpass;
+
+                switch (renderpass)
+                {
+                    case LEFT:
+                    case RIGHT:
+                        this.mainRenderTarget = this.vrRenderer.framebufferVrRender;
+                        break;
+
+                    case CENTER:
+                        this.mainRenderTarget = this.vrRenderer.framebufferUndistorted;
+                        break;
+
+                    case THIRD:
+                        this.mainRenderTarget = this.vrRenderer.framebufferMR;
+                        break;
+
+                    case SCOPEL:
+                        this.mainRenderTarget = this.vrRenderer.telescopeFramebufferL;
+                        break;
+
+                    case SCOPER:
+                        this.mainRenderTarget = this.vrRenderer.telescopeFramebufferR;
+                        break;
+
+                    case CAMERA:
+                        this.mainRenderTarget = this.vrRenderer.cameraRenderFramebuffer;
+                }
+
+                this.profiler.push("Eye:" + this.currentPass.ordinal());
+                this.profiler.push("setup");
+                this.mainRenderTarget.bindWrite(true);
+                this.profiler.pop();
+                this.renderSingleView(renderpass.ordinal(), f, pRenderLevel);
+                this.profiler.pop();
+
+                if (this.grabScreenShot)
+                {
+                    boolean flag;
+
+                    if (list.contains(RenderPass.CAMERA))
+                    {
+                        flag = renderpass == RenderPass.CAMERA;
+                    }
+                    else if (list.contains(RenderPass.CENTER))
+                    {
+                        flag = renderpass == RenderPass.CENTER;
+                    }
+                    else
+                    {
+                        flag = this.vrSettings.displayMirrorLeftEye ? renderpass == RenderPass.LEFT : renderpass == RenderPass.RIGHT;
+                    }
+
+                    if (flag)
+                    {
+                        RenderTarget rendertarget = this.mainRenderTarget;
+
+                        if (renderpass == RenderPass.CAMERA)
+                        {
+                            rendertarget = this.vrRenderer.cameraFramebuffer;
+                        }
+
+                        this.mainRenderTarget.unbindWrite();
+                        Utils.takeScreenshot(rendertarget);
+                        this.window.updateDisplay();
+                        this.grabScreenShot = false;
+                    }
+                }
+            }
+
+            if (pRenderLevel)
+            {
+                this.vrPlayer.postRender(f);
+                this.profiler.push("Display/Reproject");
+
+                try
+                {
+                    this.vrRenderer.endFrame();
+                }
+                catch (Exception exception)
+                {
+                    LOGGER.error(exception.toString());
+                }
+
+                this.profiler.pop();
+                this.checkGLError("post submit ");
+            }
+
+            if (!this.noRender)
+            {
+                Reflector.call(Reflector.BasicEventHooks_onRenderTickEnd, f);
+            }
+
+            this.profiler.push("mirror");
+            this.mainRenderTarget.unbindWrite();
+            this.copyToMirror();
+            this.drawNotifyMirror();
+            this.checkGLError("post-mirror ");
+            this.profiler.pop();
         }
 
-        this.profiler.popPush("yield");
-        Thread.yield();
-        this.profiler.pop();
         this.window.setErrorSection("Post render");
+        this.window.updateDisplay();
         ++this.frames;
-        boolean flag = this.hasSingleplayerServer() && (this.screen != null && this.screen.isPauseScreen() || this.overlay != null && this.overlay.isPauseScreen()) && !this.singleplayerServer.isPublished();
+        boolean flag1 = this.hasSingleplayerServer() && (this.screen != null && this.screen.isPauseScreen() || this.overlay != null && this.overlay.isPauseScreen()) && !this.singleplayerServer.isPublished();
 
-        if (this.pause != flag)
+        if (this.pause != flag1)
         {
             if (this.pause)
             {
@@ -1237,12 +1685,12 @@
                 this.timer.partialTick = this.pausePartialTick;
             }
 
-            this.pause = flag;
+            this.pause = flag1;
         }
 
-        long l = Util.getNanos();
-        this.frameTimer.logFrameDuration(l - this.lastNanoTime);
-        this.lastNanoTime = l;
+        long k = Util.getNanos();
+        this.frameTimer.logFrameDuration(k - this.lastNanoTime);
+        this.lastNanoTime = k;
         this.profiler.push("fpsUpdate");
 
         while (Util.getMillis() >= this.lastTime + 1000L)
@@ -1252,7 +1700,6 @@
             this.lastTime += 1000L;
             this.frames = 0;
         }
-
         this.profiler.pop();
     }
 
@@ -1323,14 +1770,19 @@
         int i = this.window.calculateScale(this.options.guiScale, this.isEnforceUnicode());
         this.window.setGuiScale((double)i);
 
+        if (this.vrRenderer != null)
+        {
+            this.vrRenderer.reinitFrameBuffers("Main Window Changed");
+        }
+
         if (this.screen != null)
         {
             this.screen.resize(this, this.window.getGuiScaledWidth(), this.window.getGuiScaledHeight());
+            //FORGE
+            Reflector.call(Reflector.ForgeHooksClient_resizeGuiLayers, this, this.window.getGuiScaledWidth(), this.window.getGuiScaledHeight());
+            //
         }
 
-        RenderTarget rendertarget = this.getMainRenderTarget();
-        rendertarget.resize(this.window.getWidth(), this.window.getHeight(), ON_OSX);
-        this.gameRenderer.resize(this.window.getWidth(), this.window.getHeight());
         this.mouseHandler.setIgnoreFirstMove();
     }
 
@@ -1341,7 +1793,7 @@
 
     private int getFramerateLimit()
     {
-        return this.level != null || this.screen == null && this.overlay == null ? this.window.getFramerateLimit() : 60;
+        return this.level == null && (this.screen != null || this.overlay != null) ? 60 : this.window.getFramerateLimit();
     }
 
     public void emergencySave()
@@ -1558,6 +2010,17 @@
         }
     }
 
+//Vivecraft
+    public void drawProfiler()
+    {
+        if (this.fpsPieResults != null)
+        {
+            this.profiler.push("fpsPie");
+            this.renderFpsMeter(new PoseStack(), this.fpsPieResults);
+            this.profiler.pop();
+        }
+    }
+//
     private void renderFpsMeter(PoseStack pPoseStack, ProfileResults pProfilerResult)
     {
         List<ResultField> list = pProfilerResult.getTimes(this.debugPath);
@@ -1714,19 +2177,47 @@
             {
                 BlockHitResult blockhitresult = (BlockHitResult)this.hitResult;
                 BlockPos blockpos = blockhitresult.getBlockPos();
+                Object object = null;
 
-                if (!this.level.getBlockState(blockpos).isAir())
+                if (!this.level.isEmptyBlock(blockpos))
                 {
-                    Direction direction = blockhitresult.getDirection();
+                	//Forge
+                    object = Reflector.call(Reflector.ForgeHooksClient_OnClickInput, 0, this.options.keyAttack, InteractionHand.MAIN_HAND);
+
+                    if (object != null && Reflector.callBoolean(object, Reflector.Event_isCanceled))
+                    {
+                        if (Reflector.callBoolean(object, Reflector.ClickInputEvent_shouldSwingHand))
+                        {
+                            this.particleEngine.addBlockHitEffects(blockpos, blockhitresult);
+                            this.player.swingArm(InteractionHand.MAIN_HAND, VRFirstPersonArmSwing.Attack);
+                        }
 
+                        return;
+                    }
+                    //
+                    
+                    Direction direction = blockhitresult.getDirection();
+                    //Forge
                     if (this.gameMode.continueDestroyBlock(blockpos, direction))
                     {
-                        this.particleEngine.crack(blockpos, direction);
-                        this.player.swing(InteractionHand.MAIN_HAND);
+                        if (object != null)
+                        {
+                            if (Reflector.callBoolean(object, Reflector.ClickInputEvent_shouldSwingHand))
+                            {
+                                this.particleEngine.addBlockHitEffects(blockpos, blockhitresult);
+                                this.player.swingArm(InteractionHand.MAIN_HAND, VRFirstPersonArmSwing.Attack);
+                            }
+                        }
+                        else
+                        {
+                            this.particleEngine.crack(blockpos, direction);
+                            this.player.swingArm(InteractionHand.MAIN_HAND, VRFirstPersonArmSwing.Attack);
+                        }
                     }
+                    //
                 }
             }
-            else
+            else if (this.vrSettings.seated)
             {
                 this.gameMode.stopDestroyBlock();
             }
@@ -1787,18 +2278,32 @@
                     }
 
                     this.player.resetAttackStrengthTicker();
+                    Reflector.call(Reflector.ForgeHooks_onEmptyLeftClick, this.player);
             }
+            
+            Object object = Reflector.call(Reflector.ForgeHooksClient_OnClickInput, 0, this.options.keyAttack, InteractionHand.MAIN_HAND);
 
+            if (object == null || Reflector.callBoolean(object, Reflector.ClickInputEvent_shouldSwingHand))
+            {
             this.player.swing(InteractionHand.MAIN_HAND);
+                            }
             return flag;
         }
     }
 
-    private void startUseItem()
+    public void startUseItem()
     {
-        if (!this.gameMode.isDestroying())
+        if (!this.gameMode.isDestroying() || !this.vrSettings.seated)
         {
-            this.rightClickDelay = 4;
+            if(vrSettings.rightclickDelay == VRSettings.RightClickDelay.VANILLA)
+            	this.rightClickDelay = 4;
+            else if(vrSettings.rightclickDelay == VRSettings.RightClickDelay.SLOW)
+            	this.rightClickDelay = 6;
+            else if(vrSettings.rightclickDelay == VRSettings.RightClickDelay.SLOWER)
+            	this.rightClickDelay = 8;
+            else if(vrSettings.rightclickDelay == VRSettings.RightClickDelay.SLOWEST)
+            	this.rightClickDelay = 10;         
+            
 
             if (!this.player.isHandsBusy())
             {
@@ -1809,80 +2314,108 @@
 
                 for (InteractionHand interactionhand : InteractionHand.values())
                 {
-                    ItemStack itemstack = this.player.getItemInHand(interactionhand);
+                    Object object = Reflector.call(Reflector.ForgeHooksClient_OnClickInput, 1, this.options.keyUse, interactionhand);
 
-                    if (this.hitResult != null)
+                    if (object != null && Reflector.callBoolean(object, Reflector.Event_isCanceled))
                     {
-                        switch (this.hitResult.getType())
+                        if (Reflector.callBoolean(object, Reflector.ClickInputEvent_shouldSwingHand))
                         {
-                            case ENTITY:
-                                EntityHitResult entityhitresult = (EntityHitResult)this.hitResult;
-                                Entity entity = entityhitresult.getEntity();
+                            this.player.swing(interactionhand);
+                        }
 
-                                if (!this.level.getWorldBorder().isWithinBounds(entity.blockPosition()))
-                                {
-                                    return;
-                                }
+                        return;
+                    }
 
-                                InteractionResult interactionresult = this.gameMode.interactAt(this.player, entity, entityhitresult, interactionhand);
+                    ItemStack itemstack = this.player.getItemInHand(interactionhand);
 
-                                if (!interactionresult.consumesAction())
-                                {
-                                    interactionresult = this.gameMode.interact(this.player, entity, interactionhand);
-                                }
+                    if (vrSettings.seated || !TelescopeTracker.isTelescope(itemstack))
+                    {
+                        NetworkHelper.sendActiveHand((byte)interactionhand.ordinal());
 
-                                if (interactionresult.consumesAction())
-                                {
-                                    if (interactionresult.shouldSwing())
+                        if (this.hitResult != null)
+                        {
+                            switch (this.hitResult.getType())
+                            {
+                                case ENTITY:
+                                    //this.physicalGuiManager.preClickAction();
+                                    EntityHitResult entityhitresult = (EntityHitResult)this.hitResult;
+                                    Entity entity = entityhitresult.getEntity();
+                                    
+	                                if (!this.level.getWorldBorder().isWithinBounds(entity.blockPosition()))
+	                                {
+	                                    return;
+	                                }
+	                                
+                                    InteractionResult interactionresult = this.gameMode.interactAt(this.player, entity, entityhitresult, interactionhand);
+
+                                    if (!interactionresult.consumesAction())
                                     {
-                                        this.player.swing(interactionhand);
+                                        interactionresult = this.gameMode.interact(this.player, entity, interactionhand);
                                     }
 
-                                    return;
-                                }
+                                    if (interactionresult.consumesAction())
+                                    {
+                                        if (interactionresult.shouldSwing() && (object == null || Reflector.callBoolean(object, Reflector.ClickInputEvent_shouldSwingHand)))
+                                        {
+                                            this.player.swingArm(interactionhand, VRFirstPersonArmSwing.Use);
+                                        }
 
-                                break;
+                                        return;
+                                    }
 
-                            case BLOCK:
-                                BlockHitResult blockhitresult = (BlockHitResult)this.hitResult;
-                                int i = itemstack.getCount();
-                                InteractionResult interactionresult1 = this.gameMode.useItemOn(this.player, this.level, interactionhand, blockhitresult);
+                                    break;
 
-                                if (interactionresult1.consumesAction())
-                                {
-                                    if (interactionresult1.shouldSwing())
-                                    {
-                                        this.player.swing(interactionhand);
+                                case BLOCK:
+                                    BlockHitResult blockhitresult = (BlockHitResult)this.hitResult;
+                                    int i = itemstack.getCount();
+                                    InteractionResult interactionresult1 = this.gameMode.useItemOn(this.player, this.level, interactionhand, blockhitresult);
 
-                                        if (!itemstack.isEmpty() && (itemstack.getCount() != i || this.gameMode.hasInfiniteItems()))
+                                    if (interactionresult1.consumesAction())
+                                    {
+                                        if (interactionresult1.shouldSwing())
                                         {
-                                            this.gameRenderer.itemInHandRenderer.itemUsed(interactionhand);
+                                            if (object == null || Reflector.callBoolean(object, Reflector.ClickInputEvent_shouldSwingHand))
+                                            {
+                                                this.player.swingArm(interactionhand, VRFirstPersonArmSwing.Use);
+                                            }
+
+                                            if (!itemstack.isEmpty() && (itemstack.getCount() != i || this.gameMode.hasInfiniteItems()))
+                                            {
+                                                this.gameRenderer.itemInHandRenderer.itemUsed(interactionhand);
+                                            }
                                         }
-                                    }
 
-                                    return;
-                                }
+                                        return;
+                                    }
 
-                                if (interactionresult1 == InteractionResult.FAIL)
-                                {
-                                    return;
-                                }
+                                    if (interactionresult1 == InteractionResult.FAIL)
+                                    {
+                                        return;
+                                    }
+                            }
                         }
-                    }
 
-                    if (!itemstack.isEmpty())
-                    {
-                        InteractionResult interactionresult2 = this.gameMode.useItem(this.player, this.level, interactionhand);
+                        //this.physicalGuiManager.preClickAction();
+
+                        if (itemstack.isEmpty() && (this.hitResult == null || this.hitResult.getType() == HitResult.Type.MISS))
+                        {
+                            Reflector.call(Reflector.ForgeHooks_onEmptyClick, this.player, interactionhand);
+                        }
 
-                        if (interactionresult2.consumesAction())
+                        if (!itemstack.isEmpty())
                         {
-                            if (interactionresult2.shouldSwing())
+                            InteractionResult interactionresult2 = this.gameMode.useItem(this.player, this.level, interactionhand);
+
+                            if (interactionresult2.consumesAction())
                             {
-                                this.player.swing(interactionhand);
-                            }
+                                if (interactionresult2.shouldSwing())
+                                {
+                                    this.player.swingArm(interactionhand, VRFirstPersonArmSwing.Use);
+                                }
 
-                            this.gameRenderer.itemInHandRenderer.itemUsed(interactionhand);
-                            return;
+                                this.gameRenderer.itemInHandRenderer.itemUsed(interactionhand);
+                                return;
+                            }
                         }
                     }
                 }
@@ -1897,15 +2430,18 @@
 
     public void tick()
     {
+        ++this.tickCounter;
+
         if (this.rightClickDelay > 0)
         {
             --this.rightClickDelay;
         }
-
+        //Forge
+        Reflector.call(Reflector.BasicEventHooks_onPreClientTick);
+        //
         this.profiler.push("gui");
         this.gui.tick(this.pause);
         this.profiler.pop();
-        this.gameRenderer.pick(1.0F);
         this.tutorial.onLookAt(this.level, this.hitResult);
         this.profiler.push("gameMode");
 
@@ -1915,11 +2451,7 @@
         }
 
         this.profiler.popPush("textures");
-
-        if (this.level != null)
-        {
-            this.textureManager.tick();
-        }
+        this.textureManager.tick();
 
         if (this.screen == null && this.player != null)
         {
@@ -1965,6 +2497,10 @@
             this.gui.clearCache();
         }
 
+        this.profiler.popPush("vrProcessInputs");
+        this.vr.processInputs();
+        this.vr.processBindings();
+
         if (this.overlay == null && (this.screen == null || this.screen.passEvents))
         {
             this.profiler.popPush("Keybindings");
@@ -1976,13 +2512,35 @@
             }
         }
 
-        if (this.level != null)
+        this.profiler.popPush("vrInputActionsTick");
+
+        for (VRInputAction vrinputaction : this.vr.getInputActions())
         {
-            this.profiler.popPush("gameRenderer");
+            vrinputaction.tick();
+        }
 
-            if (!this.pause)
-            {
-                this.gameRenderer.tick();
+        if (this.vrSettings.displayMirrorMode == VRSettings.MirrorMode.MIXED_REALITY || this.vrSettings.displayMirrorMode == VRSettings.MirrorMode.THIRD_PERSON)
+        {
+            VRHotkeys.handleMRKeys();
+        }
+
+        if (this.level != null)
+        {
+            if (this.player != null)
+            {
+                this.vrPlayer.updateFreeMove();
+
+                if (this.vrPlayer.teleportWarningTimer >= 0 && --this.vrPlayer.teleportWarningTimer == 0)
+                {
+                    this.gui.getChat().addMessage(new TranslatableComponent("vivecraft.messages.noserverplugin"));
+                }
+            }
+
+            this.profiler.popPush("gameRenderer");
+
+            if (!this.pause)
+            {
+                this.gameRenderer.tick();
             }
 
             this.profiler.popPush("levelRenderer");
@@ -2009,6 +2567,13 @@
             this.gameRenderer.shutdownEffect();
         }
 
+        if (this.menuWorldRenderer != null)
+        {
+            this.menuWorldRenderer.tick();
+        }
+        
+        PlayerModelController.getInstance().tick();
+
         if (!this.pause)
         {
             this.musicManager.tick();
@@ -2080,24 +2645,23 @@
         this.profiler.popPush("keyboard");
         this.keyboardHandler.tick();
         this.profiler.pop();
+        //Forge
+        Reflector.call(Reflector.BasicEventHooks_onPostClientTick);
+        //
     }
 
-    private boolean isMultiplayerServer()
+    public boolean isMultiplayerServer()
     {
         return !this.isLocalServer || this.singleplayerServer != null && this.singleplayerServer.isPublished();
     }
 
     private void handleKeybinds()
     {
-        for (; this.options.keyTogglePerspective.consumeClick(); this.levelRenderer.needsUpdate())
+        while (this.options.keyTogglePerspective.consumeClick())
         {
-            CameraType cameratype = this.options.getCameraType();
-            this.options.setCameraType(this.options.getCameraType().cycle());
-
-            if (cameratype.isFirstPerson() != this.options.getCameraType().isFirstPerson())
-            {
-                this.gameRenderer.checkEntityPostEffect(this.options.getCameraType().isFirstPerson() ? this.getCameraEntity() : null);
-            }
+            this.vrSettings.setOptionValue(VRSettings.VrOptions.MIRROR_DISPLAY);
+            this.notifyMirror(this.vrSettings.getButtonDisplayString(VRSettings.VrOptions.MIRROR_DISPLAY), false, 3000);
+            this.levelRenderer.needsUpdate();
         }
 
         while (this.options.keySmoothCamera.consumeClick())
@@ -2176,7 +2740,7 @@
         {
             if (!this.player.isSpectator() && this.player.drop(Screen.hasControlDown()))
             {
-                this.player.swing(InteractionHand.MAIN_HAND);
+                this.player.swingArm(InteractionHand.MAIN_HAND, VRFirstPersonArmSwing.Attack);
             }
         }
 
@@ -2194,8 +2758,9 @@
 
         if (this.player.isUsingItem())
         {
-            if (!this.options.keyUse.isDown())
+            if (!this.options.keyUse.isDown() && (!this.bowTracker.isActive(this.player) || this.vrSettings.seated) && !this.autoFood.isEating())
             {
+                NetworkHelper.sendActiveHand((byte)this.player.getUsedItemHand().ordinal());
                 this.gameMode.releaseUsingItem(this.player);
             }
 
@@ -2244,30 +2809,30 @@
 
     public void loadLevel(String pLevelName)
     {
-        this.doLoadLevel(pLevelName, WorldStem.DataPackConfigSupplier::loadFromWorld, WorldStem.WorldDataSupplier::loadFromWorld, false, Minecraft.ExperimentalDialogType.BACKUP);
-    }
-
-    public void createLevel(String pLevelName, LevelSettings pLevelSettings, RegistryAccess pDynamicRegistries, WorldGenSettings pDimensionGeneratorSettings)
-    {
-        this.doLoadLevel(pLevelName, (p_210684_) ->
-        {
-            return pLevelSettings::getDataPackConfig;
-        }, (p_210718_) ->
-        {
-            return (p_210712_, p_210713_) -> {
-                RegistryAccess.Writable registryaccess$writable = RegistryAccess.builtinCopy();
-                DynamicOps<JsonElement> dynamicops = RegistryOps.create(JsonOps.INSTANCE, pDynamicRegistries);
-                DynamicOps<JsonElement> dynamicops1 = RegistryOps.createAndLoad(JsonOps.INSTANCE, registryaccess$writable, p_210712_);
-                DataResult<WorldGenSettings> dataresult = WorldGenSettings.CODEC.encodeStart(dynamicops, pDimensionGeneratorSettings).setLifecycle(Lifecycle.stable()).flatMap((p_210687_) -> {
-                    return WorldGenSettings.CODEC.parse(dynamicops1, p_210687_);
-                });
-                WorldGenSettings worldgensettings = dataresult.getOrThrow(false, Util.prefix("Error reading worldgen settings after loading data packs: ", LOGGER::error));
-                return Pair.of(new PrimaryLevelData(pLevelSettings, worldgensettings, dataresult.lifecycle()), registryaccess$writable.freeze());
-            };
-        }, false, Minecraft.ExperimentalDialogType.CREATE);
-    }
-
-    private void doLoadLevel(String p_205206_, Function<LevelStorageSource.LevelStorageAccess, WorldStem.DataPackConfigSupplier> p_205207_, Function<LevelStorageSource.LevelStorageAccess, WorldStem.WorldDataSupplier> p_205208_, boolean p_205209_, Minecraft.ExperimentalDialogType p_205210_)
+    	//Forge
+        this.doLoadLevel(pLevelName, WorldStem.DataPackConfigSupplier::loadFromWorld, WorldStem.WorldDataSupplier::loadFromWorld, false, Minecraft.ExperimentalDialogType.BACKUP, false);
+        //
+    }
+
+    public void createLevel(String p_205186_, LevelSettings p_205187_, RegistryAccess p_205188_, WorldGenSettings p_205189_) {
+        this.doLoadLevel(p_205186_, (p_210684_) -> {
+           return p_205187_::getDataPackConfig;
+        }, (p_210718_) -> {
+           return (p_210712_, p_210713_) -> {
+              RegistryAccess.Writable registryaccess$writable = RegistryAccess.builtinCopy();
+              DynamicOps<JsonElement> dynamicops = RegistryOps.create(JsonOps.INSTANCE, p_205188_);
+              DynamicOps<JsonElement> dynamicops1 = RegistryOps.createAndLoad(JsonOps.INSTANCE, registryaccess$writable, p_210712_);
+              DataResult<WorldGenSettings> dataresult = WorldGenSettings.CODEC.encodeStart(dynamicops, p_205189_).setLifecycle(Lifecycle.stable()).flatMap((p_210687_) -> {
+                 return WorldGenSettings.CODEC.parse(dynamicops1, p_210687_);
+              });
+              WorldGenSettings worldgensettings = dataresult.getOrThrow(false, Util.prefix("Error reading worldgen settings after loading data packs: ", LOGGER::error));
+              return Pair.of(new PrimaryLevelData(p_205187_, worldgensettings, dataresult.lifecycle()), registryaccess$writable.freeze());
+           };
+        }, false, Minecraft.ExperimentalDialogType.CREATE, true);
+     }
+    
+    //Forge change sig
+    private void doLoadLevel(String p_205206_, Function<LevelStorageSource.LevelStorageAccess, WorldStem.DataPackConfigSupplier> p_205207_, Function<LevelStorageSource.LevelStorageAccess, WorldStem.WorldDataSupplier> p_205208_, boolean p_205209_, Minecraft.ExperimentalDialogType p_205210_, boolean creating)
     {
         LevelStorageSource.LevelStorageAccess levelstoragesource$levelstorageaccess;
 
@@ -2285,7 +2850,6 @@
 
         PackRepository packrepository = createPackRepository(levelstoragesource$levelstorageaccess);
         WorldStem worldstem;
-
         try
         {
             worldstem = this.makeWorldStem(packrepository, p_205209_, p_205207_.apply(levelstoragesource$levelstorageaccess), p_205208_.apply(levelstoragesource$levelstorageaccess));
@@ -2295,7 +2859,7 @@
             LOGGER.warn("Failed to load datapacks, can't proceed with server load", (Throwable)exception);
             this.setScreen(new DatapackLoadFailureScreen(() ->
             {
-                this.doLoadLevel(p_205206_, p_205207_, p_205208_, true, p_205210_);
+                this.doLoadLevel(p_205206_, p_205207_, p_205208_, true, p_205210_, creating);
             }));
 
             try
@@ -2334,7 +2898,9 @@
                 GameProfileCache.setUsesAuthentication(false);
                 this.singleplayerServer = MinecraftServer.spin((p_210695_) ->
                 {
-                    return new IntegratedServer(p_210695_, this, levelstoragesource$levelstorageaccess, packrepository, worldstem, minecraftsessionservice, gameprofilerepository, gameprofilecache, (p_210795_) -> {
+                    //Forge
+                	return new IntegratedServer(p_210695_, this, levelstoragesource$levelstorageaccess, packrepository, worldstem, minecraftsessionservice, gameprofilerepository, gameprofilecache, (p_210795_) -> {
+                	//
                         StoringChunkProgressListener storingchunkprogresslistener = new StoringChunkProgressListener(p_210795_ + 0);
                         this.progressListener.set(storingchunkprogresslistener);
                         return ProcessorChunkProgressListener.createStarted(storingchunkprogresslistener, this.progressTasks::add);
@@ -2387,14 +2953,24 @@
             {
             }));
             connection.send(new ClientIntentionPacket(socketaddress.toString(), 0, ConnectionProtocol.LOGIN));
-            connection.send(new ServerboundHelloPacket(this.getUser().getGameProfile()));
+            
+            //Forge
+            com.mojang.authlib.GameProfile gameProfile = this.getUser().getGameProfile();
+            if((Reflector.ForgeSession_hasCachedProperties.exists() && !Reflector.callBoolean(this.getUser(),Reflector.ForgeSession_hasCachedProperties))) {
+               gameProfile = minecraftSessionService.fillProfileProperties(gameProfile, true); //Forge: Fill profile properties upon game load. Fixes MC-52974.
+               Reflector.call(this.getUser(), Reflector.ForgeSession_setProperties, gameProfile.getProperties());
+            }
+            connection.send(new ServerboundHelloPacket(gameProfile));
+            //
             this.pendingConnection = connection;
         }
         else
         {
             this.displayExperimentalConfirmationDialog(p_205210_, p_205206_, flag, () ->
             {
-                this.doLoadLevel(p_205206_, p_205207_, p_205208_, p_205209_, Minecraft.ExperimentalDialogType.NONE);
+            	//Forge
+                this.doLoadLevel(p_205206_, p_205207_, p_205208_, p_205209_, Minecraft.ExperimentalDialogType.NONE, creating);
+                //
             });
             worldstem.close();
 
@@ -2477,10 +3053,10 @@
                             levelstoragesource$levelstorageaccess.close();
                         }
                     }
-                    catch (IOException ioexception)
+                    catch (IOException ioexception1)
                     {
                         SystemToast.onWorldDeleteFailure(this, pLevelName);
-                        LOGGER.error("Failed to delete world {}", pLevelName, ioexception);
+                        LOGGER.error("Failed to delete world {}", pLevelName, ioexception1);
                     }
                 }
             }, new TranslatableComponent("selectWorld.backupQuestion.experimental"), new TranslatableComponent("selectWorld.backupWarning.experimental"), CommonComponents.GUI_PROCEED, CommonComponents.GUI_CANCEL));
@@ -2516,6 +3092,15 @@
 
     public void setLevel(ClientLevel pLevelClient)
     {
+        this.vrPlayer.setRoomOrigin(0.0D, 0.0D, 0.0D, true);
+
+        //Forge
+        if (this.level != null)
+        {
+            Reflector.postForgeBusEvent(Reflector.newInstance(Reflector.WorldEvent_Unload_Constructor, this.level));
+        }
+        //
+
         ProgressScreen progressscreen = new ProgressScreen(true);
         progressscreen.progressStartNoAbort(new TranslatableComponent("connect.joining"));
         this.updateScreenAndTick(progressscreen);
@@ -2553,12 +3138,18 @@
         IntegratedServer integratedserver = this.singleplayerServer;
         this.singleplayerServer = null;
         this.gameRenderer.resetData();
+        //Forge
+        Reflector.call(Reflector.ClientHooks_firePlayerLogout, this.gameMode, this.player);
+        //
         this.gameMode = null;
         NarratorChatListener.INSTANCE.clear();
         this.updateScreenAndTick(pScreen);
 
         if (this.level != null)
         {
+        	//Forge
+            Reflector.postForgeBusEvent(Reflector.newInstance(Reflector.WorldEvent_Unload_Constructor, this.level));
+            //
             if (integratedserver != null)
             {
                 this.profiler.push("waitForServer");
@@ -2575,6 +3166,9 @@
             this.gui.onDisconnected();
             this.currentServer = null;
             this.isLocalServer = false;
+            //Forge
+            Reflector.call(Reflector.ClientHooks_handleClientWorldClosing, this.level);
+            //
             this.game.onLeaveGameSession();
         }
 
@@ -2684,6 +3278,19 @@
     {
         if (this.hitResult != null && this.hitResult.getType() != HitResult.Type.MISS)
         {
+        	//Forge
+            Object object = Reflector.call(Reflector.ForgeHooksClient_OnClickInput, 2, this.options.keyPickItem, InteractionHand.MAIN_HAND);
+
+            if (object != null && !Reflector.callBoolean(object, Reflector.Event_isCanceled))
+            {
+                Reflector.call(Reflector.ForgeHooks_onPickBlock, this.hitResult, this.player, this.level);
+            }
+
+            if (object != null)
+            {
+                return;
+            }
+            //
             boolean flag = this.player.getAbilities().instabuild;
             BlockEntity blockentity = null;
             HitResult.Type hitresult$type = this.hitResult.getType();
@@ -3390,23 +3997,37 @@
         return this.renderBuffers;
     }
 
-    private static Pack createClientPackAdapter(String p_167934_, Component p_167935_, boolean p_167936_, Supplier<PackResources> p_167937_, PackMetadataSection p_167938_, Pack.Position p_167939_, PackSource p_167940_)
-    {
+    private static Pack createClientPackAdapter(String p_167934_, Component p_167935_, boolean p_167936_, Supplier<PackResources> p_167937_, PackMetadataSection p_167938_, Pack.Position p_167939_, PackSource p_167940_, boolean hidden) {
         int i = p_167938_.getPackFormat();
         Supplier<PackResources> supplier = p_167937_;
-
-        if (i <= 3)
-        {
+        if (i <= 3) {
             supplier = adaptV3(p_167937_);
         }
 
-        if (i <= 4)
-        {
+        if (i <= 4) {
             supplier = adaptV4(supplier);
         }
 
-        return new Pack(p_167934_, p_167935_, p_167936_, supplier, p_167938_, PackType.CLIENT_RESOURCES, p_167939_, p_167940_);
-    }
+        return new Pack(p_167934_, p_167935_, p_167936_, supplier, p_167938_, PackType.CLIENT_RESOURCES, p_167939_, p_167940_, hidden);
+     }
+    
+//    private static Pack createClientPackAdapter(String p_167934_, Component p_167935_, boolean p_167936_, Supplier<PackResources> p_167937_, PackMetadataSection p_167938_, Pack.Position p_167939_, PackSource p_167940_)
+//    {
+//        int i = p_167938_.getPackFormat();
+//        Supplier<PackResources> supplier = p_167937_;
+//
+//        if (i <= 3)
+//        {
+//            supplier = adaptV3(p_167937_);
+//        }
+//
+//        if (i <= 4)
+//        {
+//            supplier = adaptV4(supplier);
+//        }
+        //
+//        return new Pack(p_167934_, p_167935_, p_167936_, supplier, p_167938_, PackType.CLIENT_RESOURCES, p_167939_, p_167940_);
+//}
 
     private static Supplier<PackResources> adaptV3(Supplier<PackResources> pResourcePackSupplier)
     {
@@ -3490,6 +4111,566 @@
         public abstract boolean isChatAllowed(boolean p_168035_);
     }
 
+    public void printChatMessage(String msg)
+    {
+        if (this.level != null)
+        {
+            Component component = new TextComponent(msg);
+            this.gui.getChat().addMessage(component);
+        }
+    }
+
+    private void copyToMirror()
+    {
+        // TODO: fix mixed reality... again
+        if (this.vrSettings.displayMirrorMode == VRSettings.MirrorMode.MIXED_REALITY)
+            this.vrSettings.displayMirrorMode = VRSettings.MirrorMode.CROPPED;
+
+        if (this.vrSettings.displayMirrorMode == VRSettings.MirrorMode.OFF && this.vr.isHMDTracking())
+        {
+            this.notifyMirror("Mirror is OFF", true, 1000);
+        }
+        else if (this.vrSettings.displayMirrorMode == VRSettings.MirrorMode.MIXED_REALITY)
+        {
+            if (VRShaders._DepthMask_shaderProgramId != 0)
+            {
+                this.doMixedRealityMirror();
+            }
+            else
+            {
+                this.notifyMirror("Shader compile failed, see log", true, 10000);
+            }
+        }
+        else if (this.vrSettings.displayMirrorMode == VRSettings.MirrorMode.DUAL)
+        {
+            RenderTarget rendertarget = this.vrRenderer.framebufferEye0;
+            RenderTarget rendertarget1 = this.vrRenderer.framebufferEye1;
+            
+            if (rendertarget != null)
+            {
+                rendertarget.blitToScreen(0, this.window.getScreenWidth() / 2, this.window.getScreenHeight(), 0, true, 0.0F, 0.0F, false);
+            }
+
+            if (rendertarget1 != null)
+            {
+                rendertarget1.blitToScreen(this.window.getScreenWidth() / 2, this.window.getScreenWidth() / 2, this.window.getScreenHeight(), 0, true, 0.0F, 0.0F, false);
+            }
+        }
+        else
+        {
+            float xcrop = 0.0F;
+            float ycrop = 0.0F;
+            boolean ar = false;
+            RenderTarget source = this.vrRenderer.framebufferEye0;
+
+            if (this.vrSettings.displayMirrorMode == VRSettings.MirrorMode.FIRST_PERSON)
+            {
+                source = this.vrRenderer.framebufferUndistorted;
+            }
+            else if (this.vrSettings.displayMirrorMode == VRSettings.MirrorMode.THIRD_PERSON)
+            {
+                source = this.vrRenderer.framebufferMR;
+            }
+            else if (this.vrSettings.displayMirrorMode == VRSettings.MirrorMode.SINGLE || this.vrSettings.displayMirrorMode == VRSettings.MirrorMode.OFF)
+            {
+                if (!this.vrSettings.displayMirrorLeftEye)
+                    source = this.vrRenderer.framebufferEye1;
+            }
+            else if (this.vrSettings.displayMirrorMode == VRSettings.MirrorMode.CROPPED)
+            {
+                if (!this.vrSettings.displayMirrorLeftEye)
+                    source = this.vrRenderer.framebufferEye1;
+
+                xcrop = 0.15F;
+                ycrop = 0.15F;
+                ar = true;
+            }
+            //Debug
+            //source = GuiHandler.guiFramebuffer;
+            //source = vrRenderer.telescopeFramebufferR;
+            //
+            if (source != null)
+            {
+                source.blitToScreen(0, this.window.getScreenWidth(), this.window.getScreenHeight(), 0, true, xcrop, ycrop, ar);
+            }
+        }
+    }
+
+    private void doMixedRealityMirror()
+    {
+        boolean flag = Config.isShaders();
+        boolean flag1 = this.vrSettings.mixedRealityUnityLike && this.vrSettings.mixedRealityAlphaMask;
+
+        if (!flag1)
+        {
+            GlStateManager._clearColor((float)this.vrSettings.mixedRealityKeyColor.getRed() / 255.0F, (float)this.vrSettings.mixedRealityKeyColor.getGreen() / 255.0F, (float)this.vrSettings.mixedRealityKeyColor.getBlue() / 255.0F, 1.0F);
+        }
+        else
+        {
+            GlStateManager._clearColor(0.0F, 0.0F, 0.0F, 1.0F);
+        }
+
+        GlStateManager.clear(16640);
+        Vec3 vec3 = this.vrPlayer.vrdata_room_pre.getHeadPivot().subtract(this.vrPlayer.vrdata_room_pre.getEye(RenderPass.THIRD).getPosition());
+        com.mojang.math.Matrix4f matrix4f = this.vrPlayer.vrdata_room_pre.getEye(RenderPass.THIRD).getMatrix().transposed().toMCMatrix();
+        Vector3 vector3 = this.vrPlayer.vrdata_room_pre.getEye(RenderPass.THIRD).getMatrix().transform(Vector3.forward());
+        GlStateManager._glUseProgram(VRShaders._DepthMask_shaderProgramId);
+        this.gameRenderer.thirdPassProjectionMatrix.store(this.matrixBuffer);
+        ((Buffer)this.matrixBuffer).rewind();
+        ARBShaderObjects.glUniformMatrix4fvARB(VRShaders._DepthMask_projectionMatrix, false, this.matrixBuffer);
+        matrix4f.store(this.matrixBuffer);
+        ((Buffer)this.matrixBuffer).rewind();
+        ARBShaderObjects.glUniformMatrix4fvARB(VRShaders._DepthMask_viewMatrix, false, this.matrixBuffer);
+        ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_colorTexUniform, 1);
+        ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_depthTexUniform, 2);
+        ARBShaderObjects.glUniform3fARB(VRShaders._DepthMask_hmdViewPosition, (float)vec3.x, (float)vec3.y, (float)vec3.z);
+        ARBShaderObjects.glUniform3fARB(VRShaders._DepthMask_hmdPlaneNormal, -vector3.getX(), 0.0F, -vector3.getZ());
+        ARBShaderObjects.glUniform3fARB(VRShaders._DepthMask_keyColorUniform, (float)this.vrSettings.mixedRealityKeyColor.getRed() / 255.0F, (float)this.vrSettings.mixedRealityKeyColor.getGreen() / 255.0F, (float)this.vrSettings.mixedRealityKeyColor.getBlue() / 255.0F);
+        ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_alphaModeUniform, flag1 ? 1 : 0);
+        GlStateManager._activeTexture(33985);
+        this.vrRenderer.framebufferMR.bindRead();
+        GlStateManager._activeTexture(33986);
+
+        if (flag && Shaders.dfb != null)
+        {
+            GlStateManager._bindTexture(Shaders.dfb.depthTextures.get(0));
+        }
+        else
+        {
+            GlStateManager._bindTexture(this.vrRenderer.framebufferMR.getDepthBufferId());
+        }
+
+        GlStateManager._activeTexture(33984);
+
+        for (int i = 0; i < (flag1 ? 3 : 2); ++i)
+        {
+            int j = this.window.getScreenWidth() / 2;
+            int k = this.window.getScreenHeight();
+            int l = this.window.getScreenWidth() / 2 * i;
+            int i1 = 0;
+
+            if (this.vrSettings.mixedRealityUnityLike)
+            {
+                j = this.window.getScreenWidth() / 2;
+                k = this.window.getScreenHeight() / 2;
+
+                if (this.vrSettings.mixedRealityAlphaMask && i == 2)
+                {
+                    l = this.window.getScreenWidth() / 2;
+                    i1 = this.window.getScreenHeight() / 2;
+                }
+                else
+                {
+                    l = 0;
+                    i1 = this.window.getScreenHeight() / 2 * (1 - i);
+                }
+            }
+
+            ARBShaderObjects.glUniform2fARB(VRShaders._DepthMask_resolutionUniform, (float)j, (float)k);
+            ARBShaderObjects.glUniform2fARB(VRShaders._DepthMask_positionUniform, (float)l, (float)i1);
+            ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_passUniform, i);
+            this.vrRenderer.framebufferMR.blitToScreen(l, j, k, i1, true, 0.0F, 0.0F, false);
+        }
+
+        GlStateManager._glUseProgram(0);
+
+        if (this.vrSettings.mixedRealityUnityLike)
+        {
+            if (this.vrSettings.mixedRealityUndistorted)
+            {
+                this.vrRenderer.framebufferUndistorted.blitToScreen(this.window.getScreenWidth() / 2, this.window.getScreenWidth() / 2, this.window.getScreenHeight() / 2, 0, true, 0.0F, 0.0F, false);
+            }
+            else
+            {
+                this.vrRenderer.framebufferEye0.blitToScreen(this.window.getScreenWidth() / 2, this.window.getScreenWidth() / 2, this.window.getScreenHeight() / 2, 0, true, 0.0F, 0.0F, false);
+            }
+        }
+    }
+
+    private void checkGLError(String message)
+    {
+        Config.checkGlError(message);
+    }
+
+    public void initMinecrift() throws Exception
+    {
+        this.vr.init();
+
+        if (!Main.oculus)
+        {
+            this.vrRenderer = new OpenVRStereoRenderer(this.vr);
+        }
+        else
+        {
+            this.vrRenderer = new OVR_StereoRenderer(this.vr);
+        }
+
+        this.vrPlayer = new VRPlayer();
+        this.vrRenderer.lastGuiScale = this.options.guiScale;
+        this.vrPlayer.registerTracker(this.backpackTracker);
+        this.vrPlayer.registerTracker(this.bowTracker);
+        this.vrPlayer.registerTracker(this.climbTracker);
+        this.vrPlayer.registerTracker(this.autoFood);
+        this.vrPlayer.registerTracker(this.jumpTracker);
+        this.vrPlayer.registerTracker(this.rowTracker);
+        this.vrPlayer.registerTracker(this.runTracker);
+        this.vrPlayer.registerTracker(this.sneakTracker);
+        this.vrPlayer.registerTracker(this.swimTracker);
+        this.vrPlayer.registerTracker(this.swingTracker);
+        this.vrPlayer.registerTracker(this.interactTracker);
+        this.vrPlayer.registerTracker(this.teleportTracker);
+        this.vrPlayer.registerTracker(this.horseTracker);
+        this.vrPlayer.registerTracker(this.vehicleTracker);
+        //this.vrPlayer.registerTracker(this.physicalGuiManager);
+        this.vrPlayer.registerTracker(this.crawlTracker);
+        this.vrPlayer.registerTracker(this.cameraTracker);
+    }
+
+    private static void sleepNanos(long nanoDelay)
+    {
+        long i = System.nanoTime() + nanoDelay;
+
+        do
+        {
+            Thread.yield();
+        }
+        while (System.nanoTime() < i);
+    }
+
+    private void addRunTickTimeNanos(long runTickTime)
+    {
+        int i = 0;
+        this.medianRunTickTimeNanos = runTickTime;
+
+        if (this.vrSettings.smoothRunTickCount < 1)
+        {
+            this.vrSettings.smoothRunTickCount = 1;
+        }
+
+        if (this.vrSettings.smoothRunTickCount % 2 == 0)
+        {
+            ++this.vrSettings.smoothRunTickCount;
+        }
+
+        this.runTickTimeNanos.addFirst(runTickTime);
+
+        while (this.runTickTimeNanos.size() > this.vrSettings.smoothRunTickCount)
+        {
+            this.runTickTimeNanos.removeLast();
+        }
+
+        if (this.runTickTimeNanos.size() == this.vrSettings.smoothRunTickCount)
+        {
+            Long[] along = new Long[this.runTickTimeNanos.size()];
+
+            for (Iterator iterator = this.runTickTimeNanos.iterator(); iterator.hasNext(); ++i)
+            {
+                along[i] = (Long)iterator.next();
+            }
+
+            Arrays.sort((Object[])along);
+            this.medianRunTickTimeNanos = along[along.length / 2];
+        }
+    }
+
+    private long getMedianRunTickTimeNanos()
+    {
+        return this.medianRunTickTimeNanos;
+    }
+
+    public void triggerYawTransition(boolean isPositive)
+    {
+    }
+
+    public void print(String s)
+    {
+        s = s.replace("\n", "\n[Minecrift] ");
+        System.out.println("[Minecrift] " + s);
+    }
+
+    private void renderSingleView(int eye, float nano, boolean renderworld)
+    {
+        GlStateManager._clearColor(0.0F, 0.0F, 0.0F, 1.0F);
+        GlStateManager.clear(16640);
+        GlStateManager._enableTexture();
+        GlStateManager._enableDepthTest();
+        this.profiler.push("updateCameraAndRender");
+        this.gameRenderer.render(nano, System.nanoTime(), renderworld);
+        this.profiler.pop();
+        this.checkGLError("post game render " + eye);
+
+        if (this.currentPass == RenderPass.LEFT || this.currentPass == RenderPass.RIGHT)
+        {
+            this.profiler.push("postprocesseye");
+            RenderTarget rendertarget = this.mainRenderTarget;
+
+            if (this.vrSettings.useFsaa)
+            {
+                this.profiler.push("fsaa");
+                this.vrRenderer.doFSAA(Config.isShaders());
+                rendertarget = this.vrRenderer.fsaaLastPassResultFBO;
+                this.checkGLError("fsaa " + eye);
+                this.profiler.pop();
+            }
+
+            if (this.currentPass == RenderPass.LEFT)
+            {
+                this.vrRenderer.framebufferEye0.bindWrite(true);
+            }
+            else
+            {
+                this.vrRenderer.framebufferEye1.bindWrite(true);
+            }
+
+            if (this.vrSettings.useFOVReduction && this.vrPlayer.getFreeMove())
+            {
+                if (this.player != null && (Math.abs(this.player.zza) > 0.0F || Math.abs(this.player.xxa) > 0.0F))
+                {
+                    this.fov = (float)((double)this.fov - 0.05D);
+
+                    if (this.fov < this.vrSettings.fovReductionMin)
+                    {
+                        this.fov = this.vrSettings.fovReductionMin;
+                    }
+                }
+                else
+                {
+                    this.fov = (float)((double)this.fov + 0.01D);
+
+                    if ((double)this.fov > 0.8D)
+                    {
+                        this.fov = 0.8F;
+                    }
+                }
+            }
+            else
+            {
+                this.fov = 1.0F;
+            }
+
+            GlStateManager._glUseProgram(VRShaders._FOVReduction_shaderProgramId);
+            ARBShaderObjects.glUniform1iARB(VRShaders._FOVReduction_TextureUniform, 0);
+            ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_OffsetUniform, this.vrSettings.fovRedutioncOffset);
+            float red = 0.0F;
+            float black = 0.0F;
+            float blue = 0.0F;
+            float time = (float)Util.getMillis() / 1000.0F;
+
+            if (this.player != null && this.level != null)
+            {
+                if (this.gameRenderer.wasinwater != this.gameRenderer.inwater)
+                {
+                    this.watereffect = 2.3F;
+                }
+                else
+                {
+                    if (this.gameRenderer.inwater)
+                    {
+                        this.watereffect -= 0.008333334F;
+                    }
+                    else
+                    {
+                        this.watereffect -= 0.016666668F;
+                    }
+
+                    if (this.watereffect < 0.0F)
+                    {
+                        this.watereffect = 0.0F;
+                    }
+                }
+
+                this.gameRenderer.wasinwater = this.gameRenderer.inwater;
+
+                if (Config.isShaders())
+                {
+                    this.watereffect = 0.0F;
+                }
+
+                if (this.gameRenderer.inportal)
+                {
+                    this.portaleffect = 1.0F;
+                }
+                else
+                {
+                    this.portaleffect -= 0.016666668F;
+
+                    if (this.portaleffect < 0.0F)
+                    {
+                        this.portaleffect = 0.0F;
+                    }
+                }
+
+                ItemStack itemstack = this.player.getInventory().getArmor(3);
+
+                if (itemstack.getItem() == Blocks.CARVED_PUMPKIN.asItem() && (!itemstack.hasTag() || itemstack.getTag().getInt("CustomModelData") == 0))
+                {
+                    this.pumpkineffect = 1.0F;
+                }
+
+                float hurtTimer = (float)this.player.hurtTime - nano;
+                float healthpercent = 1.0F - this.player.getHealth() / this.player.getMaxHealth();
+                healthpercent = (healthpercent - 0.5F) * 0.75F;
+
+                if (hurtTimer > 0.0F)
+                { //hurt flash
+                    hurtTimer = hurtTimer / (float)this.player.hurtDuration;
+                    hurtTimer = healthpercent + Mth.sin(hurtTimer * hurtTimer * hurtTimer * hurtTimer * (float)Math.PI) * 0.5F;
+                    red = hurtTimer;
+                }
+                else
+                { //red due to low health
+                    red = (float)((double)healthpercent * Math.abs(Math.sin((double)(2.5F * time) / ((double)(1.0F - healthpercent) + 0.1D))));
+
+                    if (this.player.isCreative())
+                    {
+                        red = 0.0F;
+                    }
+                }
+
+                float freeze = this.player.getPercentFrozen();
+                if(freeze > 0 ){
+                	blue = red;
+                	blue = Math.max(freeze / 2, blue);
+                	red = 0;
+                }
+                
+                
+                if (this.player.isSleeping() && (double)black < 0.8D)
+                {
+                    black = 0.8F;
+                }
+
+                if (this.vr.isWalkingAbout && (double)black < 0.8D)
+                {
+                    black = 0.5F;
+                }
+            }
+            else
+            {
+                this.watereffect = 0.0F;
+                this.portaleffect = 0.0F;
+                this.pumpkineffect = 0.0F;
+            }
+
+            if (this.pumpkineffect > 0.0F)
+            {
+                ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_RadiusUniform, 0.3F);
+                ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_BorderUniform, 0.0F);
+            }
+            else
+            {
+                ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_RadiusUniform, this.fov);
+                ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_BorderUniform, 0.06F);
+            }
+
+            ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_HealthAlpha, red);
+            ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_FreezeAlpha, blue);
+            ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_BlackAlpha, black);
+            ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_time, time);
+            ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_waterAmplitude, this.watereffect);
+            ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_portalAmplitutde, this.portaleffect);
+            ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_pumpkinAmplitutde, this.pumpkineffect);
+            RenderPass renderpass = this.currentPass;
+            ARBShaderObjects.glUniform1iARB(VRShaders._Overlay_eye, this.currentPass == RenderPass.LEFT ? 1 : -1);
+            rendertarget.blitLegacy = true;
+            rendertarget.blitToScreen(this.vrRenderer.framebufferEye0.viewWidth, this.vrRenderer.framebufferEye0.viewHeight);
+            rendertarget.blitLegacy = false;
+            GlStateManager._glUseProgram(0);
+            this.checkGLError("post overlay" + eye);
+            this.profiler.pop();
+        }
+
+        if (this.currentPass == RenderPass.CAMERA)
+        {
+            this.profiler.push("cameracopy");
+            this.vrRenderer.cameraFramebuffer.bindWrite(true);
+            GlStateManager._clearColor(0.0F, 0.0F, 0.0F, 1.0F);
+            GlStateManager.clear(16640);
+            this.vrRenderer.cameraRenderFramebuffer.blitToScreen(0, this.vrRenderer.cameraFramebuffer.viewWidth, this.vrRenderer.cameraFramebuffer.viewHeight, 0, true, 0.0F, 0.0F, false);
+            this.profiler.pop();
+        }
+    }
+
+    //Forge
+    public ItemColors getItemColors()
+    {
+        return this.itemColors;
+    }
+
+    public SearchRegistry getSearchTreeManager()
+    {
+        return this.searchRegistry;
+    }
+    //
+    
+    public void loadClassPath()
+    {
+        File file1 = new File("../src/resources");
+
+        if (file1.exists() && file1.isDirectory())
+        {
+            Method method = null;
+
+            try
+            {
+                method = URLClassLoader.class.getDeclaredMethod("addURL", URL.class);
+                method.setAccessible(true);
+                method.invoke(ClassLoader.getSystemClassLoader(), file1.toURI().toURL());
+            }
+            catch (Exception exception)
+            {
+                exception.printStackTrace();
+            }
+        }
+    }
+
+    public void notifyMirror(String text, boolean clear, int lengthMs)
+    {
+        this.mirroNotifyStart = System.currentTimeMillis();
+        this.mirroNotifyLen = (long)lengthMs;
+        this.mirrorNotifyText = text;
+        this.mirrorNotifyClear = clear;
+    }
+
+    public void drawNotifyMirror()
+    {
+        if (System.currentTimeMillis() < this.mirroNotifyStart + this.mirroNotifyLen)
+        {
+            RenderSystem.viewport(0, 0, this.window.getScreenWidth(), this.window.getScreenHeight());
+            Matrix4f matrix4f = Matrix4f.orthographic(0.0F, (float)this.window.getScreenWidth(), 0.0F, (float)this.window.getScreenHeight(), 1000.0F, 3000.0F);
+            RenderSystem.setProjectionMatrix(matrix4f);
+            RenderSystem.getModelViewStack().setIdentity();
+            RenderSystem.getModelViewStack().translate(0, 0, -2000);
+            RenderSystem.applyModelViewMatrix();
+            PoseStack p = new PoseStack();
+            p.scale(3, 3, 3);
+            RenderSystem.clear(256, ON_OSX);
+            
+            if (this.mirrorNotifyClear)
+            {
+                RenderSystem.clearColor(0,0,0,0);
+                RenderSystem.clear(16384, ON_OSX);
+            }
+
+            int i = this.window.getScreenWidth() / 22;
+            ArrayList<String> arraylist = new ArrayList<>();
+
+            if (this.mirrorNotifyText != null)
+            {
+                Utils.wordWrap(this.mirrorNotifyText, i, arraylist);
+            }
+
+            int j = 1;
+            int k = 12;
+
+            for (String s : arraylist)
+            {
+                this.font.draw(p, s, 1.0F, (float)j, 16777215);
+                j += 12;
+            }
+        }
+    }
+
     static enum ExperimentalDialogType
     {
         NONE,
